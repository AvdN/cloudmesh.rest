\documentclass[9pt,twocolumn,twoside]{styles/osajnl} 
\usepackage{fancyvrb}
\journal{cm}  

%\usepackage{xcolor}
%usepackage{fullpage}
%\usepackage{fancyvrb}
%\renewcommand{\familydefault}{\sfdefault}
%\usepackage[scaled=0.92]{helvet}
%\usepackage[helvet]{sfmath}
%\everymath={\sf}
%\parindent 0pt

\newcommand{\tightlist}{}

\title{Cloudmesh REST Interface for Virtual Clusters} 

\author[1,*]{Gregor von Laszewski} 
\author[1]{Fugang Wang}
\author[1]{Badi Abdhul-Wahid}

\affil[1]{School of Informatics and Computing, Bloomington, IN 47408, U.S.A.} 
\affil[*]{Corresponding authors: laszewski@gmal.com} 

\dates{Draft v0.0.1, \today} 

\ociscodes{CLoudmesh, REST, NIST} 

\doi{\url{https://github.com/cloudmesh/rest/tree/master/resources/docs}} 


\begin{abstract}

This document summarizes a number of objects that are instrumental for
the interaction with Clouds, Containers, and HPC systems to manage
virtual clusters. 
TBD

\end{abstract}

\begin{document}


\flushbottom % Makes all text pages the same height

\maketitle % Print the title and abstract box

\tableofcontents % Print the contents section
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{User Profile}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{profile}

\VerbatimInput{../samples/profile.json}

\subsection{user}

\VerbatimInput{../samples/user.json}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Var}

\VerbatimInput{../samples/var.json}

\subsection{Default}

\VerbatimInput{../samples/default.json}

\subsection{File}

The \textbf{file} object has \textit{name}, \textit{endpoint} (location), \textit{size}
in GB, MB, Byte, \textit{checksum} for integrity check, and last \textit{accessed} timestamp.

\VerbatimInput{../samples/file.json}

\subsection{File Alias}

A file could have one alias or even multiple ones.

\VerbatimInput{../samples/file_alias.json}

\subsection{Replica}

\VerbatimInput{../samples/replica.json}


\subsection{Virtual Directory}

\VerbatimInput{../samples/virtual_directory.json}

\subsection{Database}

A \textbf{database} could have a name, an \textit{endpoint} (e.g., host:port),
and protocol used (e.g., SQL, mongo, etc.).

\VerbatimInput{../samples/database.json}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{IaaS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% ----------------------------------------------------------------------
\subsection{Openstack}
% ----------------------------------------------------------------------

\subsubsection{Openstack Flavor}

\VerbatimInput{../samples/openstack_flavor.json}

\subsubsection{Openstack Image}

\VerbatimInput{../samples/openstack_image.json}

\subsubsection{Openstack Vm}

\VerbatimInput{../samples/openstack_vm.json}

% ----------------------------------------------------------------------
\subsection{Azure}
% ----------------------------------------------------------------------

\subsubsection{Azure Size}

The size description of an azure vm

\VerbatimInput{../samples/azure-size.json}


\subsubsection{Azure Image}

\VerbatimInput{../samples/azure-image.json}

\subsubsection{Azure Vm}

An Azure virtual machine
\VerbatimInput{../samples/azure-vm.json}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HPC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Batch Job}

\VerbatimInput{../samples/batchjob.json}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Virtual Cluster}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Cluster}

The cluster object has name, label, endpoint and provider. The \textit{endpoint}
defines.... The \textit{provider} defines the nature of the cluster,
e.g., its a virtual cluster on an openstack cloud, or from AWS, or a bare-metal
cluster.


\VerbatimInput{../samples/cluster.json}
\
\subsection{Compute Resource}

\textbf{compute\_resource} object has attribute \textit{endpoint} which
specifies ... The \textit{kind} could be \textit{baremetal} or \textit{VC}.

\VerbatimInput{../samples/compute_resource.json}

\subsection{Computer}

This defines a \textbf{computer} object. A computer has name, label,
IP address. It also listed the relevant specs such as memory, disk
size, etc.

\VerbatimInput{../samples/computer.json}


\subsection{node}

A node is composed of multiple components:

\begin{enumerate}
\item Metadata such as the \verb|name| or \verb|owner|.
\item Physical properties such as \verb|cores| or \verb|memory|.
\item Configuration guidance such as \verb|create_external_ip|,
  \verb|security_groups|, or \verb|users|.
\end{enumerate}

The metadata is associated with the node on the provider end (if
supported) as well as in the database. Certain parts of the metadata
(such as \verb|owner|) can be used to implement access
control. Physical properties are relevant for the initial allocation
of the node. Other configuration parameters control and further
provisioning.

In the above, after allocation, the node is configured with a user
called \verb|hello| who is part of the \verb|wheel| group whose
account can be accessed with several SSH identities whose public keys
are provided (in \verb|authorized_keys|).

Additionally, three ssh keys are generated on the node for the
\verb|hello| user. The first uses the \verb|ed25519| cryptographic
method with a password read in from a GPG-encrypted file on the
Command and Control node. The second is a 4098-bit RSA key also
password-protected from the GPG-encrypted file. The third key is
copied to the remote node from an encrypted file on the Command and
Control node.

This definition also provides a security group to control access to
the node from the wide-area-network. In this case all ingress and
egress TCP and UDP traffic is allowed provided they are to ports 22
(SSH), 443 (SSL), and 80 and 8080 (web).


\VerbatimInput{../samples/node-new.json}



\subsection{Virtual Cluster}

\VerbatimInput{../samples/virtual_cluster.json}

\subsection{Virtual Compute node}

\VerbatimInput{../samples/virtual_compute_node.json}

\subsection{Virtual Machine}

\VerbatimInput{../samples/virtual_machine.json}

\subsection{Mesos}

\VerbatimInput{../samples/mesos.json}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Containers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Container}

This defines \textbf{container} object.

\VerbatimInput{../samples/container.json}

\subsection{Kubernetes}

\VerbatimInput{../samples/kubernetes.json}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Deployment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Deployment}

A \textbf{deployment} consists of the resource \- \textit{cluster},
the location \- \textit{provider}, e.g., AWS, OpenStack, etc., and
software \textit{stack} to be deployed (e.g., hadoop, spark).

\VerbatimInput{../samples/deployment.json}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mapreduce}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hadoop}

A \textbf{hadoop} definition defines which \textit{deployer} to be used,
the \textit{parameters} of the deployment, and the system packages as
\textit{requires}. For each requirement, it could have attributes such
as the library origin, version, etc.

\VerbatimInput{../samples/hadoop.json}


\subsection{Mapreduce}

This defines a \textbf{mapreduce} deployment with its layered
components.

\VerbatimInput{../samples/mapreduce.json}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Security}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Key}

\VerbatimInput{../samples/key.json}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Microservice}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Microservice}

A system could be composed of from various microservices, and this defines
each of them.

\VerbatimInput{../samples/microservice.json}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reservation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\VerbatimInput{../samples/reservation.json}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Network}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We are looking for volunteers to contribute here.

\newpage

\appendix

\section{Schema Command}

\VerbatimInput{schema-man.tex}


\section{Contributing}

We invite you to contribute to this paper and its discussion to
improve it. Improvements can be done with pull requests. We suggest
you do {\em small} individual changes to a single section and object
rather than large changes as this allows us to integrate the changes
individually and comment on your contribution via github.

Once contributed we will appropriately acknoledge you either as
contributor or author. Please discuss with us how we best acknowledge
you.

\section{Using the Cloudmesh REST Service} 

Components are written as YAML markup in files in the
\verb+resources/samples+ directory.

For example:

\VerbatimInput{../samples/profile.json}
\subsection{Element Definition}

Each resource should have a \verb+description+ entry to act as
documentation. The documentation should be formated as
reStructuredText. For example:

\subsection{Yaml}

\begin{Verbatim}
entry = yaml.read('''
profile:
  description: |
    A user profile that specifies general information 
    about the user
  email: laszewski@gmail.com, required
  firtsname: Gregor, required
  lastname: von Laszewski, required
  height: 180
'''}
\end{Verbatim}

\subsection{Cerberus}

\begin{Verbatim}
schema = {
'profile': {
  'description': {'type': 'string'}
  'email':       {'type': 'string', 'required': True}
  'firtsname':   {'type': 'string', 'required': True}
  'lastname':    {'type': 'string', 'required': True}
  'height':      {'type': 'float'}
}
\end{Verbatim}

\section{Mongoengine}

\begin{Verbatim}
class profile(Document):
    description = StringField()
    email = EmailField(required=True)
    firstname = StringField(required=True)
    lastname = StringField(required=True)
    height = FloatField(max_length=50)
\end{Verbatim}

\section{Cloudmesh Notation}

\begin{Verbatim}
profile:
    description: string
    email: email, required
    firstname: string, required
    lastname: string, required
    height: flat, max=10
\end{Verbatim}

\begin{Verbatim}
proposed command

cms schema FILENAME --format=mongo -o OUTPUT
cms schema FILENAME --format=cerberus -o OUTPUT
cms schema FILENAME --format=yaml -o OUTPUT

  reads FILENAME in cloudmesh notation and returns format


cms schema FILENAME --input=evegenie -o OUTPUT
   reads eavegene example and create settings for eve
\end{Verbatim}


\subsection{Defining Elements for the REST Service}

To manage a large number of elements defined in our REST service
easily, we manage them trhough definitions in yaml files. To generate
the appropriate settings file for the rest service, we can use teh
following command:

\begin{verbatim}
cms admin elements <directory> <out.json>
\end{verbatim}

where

\begin{itemize}
\item \verb+<directory>+: directory where the YAML definitions reside
\item \verb+<out.json>+: path to the combined definition
\end{itemize}

For example, to generate a file called all.json that integrates all
yml objects defined in the directory \verb+resources/samples+ you can
use the following command:

\begin{verbatim}
cms elements resources/samples all.json
\end{verbatim}

\subsection{DOIT}


cms schema spec2tex resources/specification resources/tex

\subsection{Generating service}

With evegenie installed, the generated JSON file from the above step
is processed to create the stub REST service definitions.


\section{ABC}
{\bf README.rst}
\input{readme}
classes lessons rest.rst
\input{rest}
classes lesson python cmd5.rst
\input{python-cmd5}



\end{document}



