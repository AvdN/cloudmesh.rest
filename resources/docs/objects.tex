\documentclass[9pt,twocolumn,twoside]{styles/osajnl} 
\usepackage{fancyvrb}
\journal{cm}  

%\usepackage{xcolor}
%usepackage{fullpage}
%\usepackage{fancyvrb}
%\renewcommand{\familydefault}{\sfdefault}
%\usepackage[scaled=0.92]{helvet}
%\usepackage[helvet]{sfmath}
%\everymath={\sf}
%\parindent 0pt

\newcommand{\tightlist}{}

\title{Cloudmesh REST Interface for Virtual Clusters} 

\author[1,*]{Gregor von Laszewski} 
\author[1]{Fugang Wang}
\author[1]{Badi Abdhul-Wahid}

\affil[1]{School of Informatics and Computing, Bloomington, IN 47408, U.S.A.} 
\affil[*]{Corresponding authors: laszewski@gmal.com} 

\dates{Draft v0.0.1, \today} 

\ociscodes{CLoudmesh, REST, NIST} 

\doi{\url{https://github.com/cloudmesh/rest/tree/master/resources/docs}} 


\begin{abstract}

This document summarizes a number of objects that are instrumental for
the interaction with Clouds, Containers, and HPC systems to manage
virtual clusters. 
TBD

\end{abstract}

\begin{document}


\flushbottom % Makes all text pages the same height

\maketitle % Print the title and abstract box

\tableofcontents % Print the contents section
\maketitle



\section{Contributing}

We invite you to contribute to this paper and its discussion to
improve it. Improvements can be done with pull requests. We suggest
you do {\em small} individual changes to a single section and object
rather than large changes as this allows us to integrate the changes
individually and comment on your contribution via github.

Once contributed we will appropriately acknoledge you either as
contributor or author. Please discuss with us how we best acknowledge
you.

\section{Using the Cloudmesh REST Service} 

Components are written as YAML markup in files in the
\verb+resources/samples+ directory.

For example:

\VerbatimInput{specification/profile.yml}

\subsection{Element Definition}

Each resource should have a \verb+description+ entry to act as
documentation. The documentation should be formated as
reStructuredText. For example:

\subsection{Yaml}

\begin{Verbatim}
entry = yaml.read('''
profile:
  description: |
    A user profile that specifies general information 
    about the user
  email: laszewski@gmail.com, required
  firtsname: Gregor, required
  lastname: von Laszewski, required
  height: 180
'''}
\end{Verbatim}

\subsection{Cerberus}

\begin{Verbatim}
schema = {
'profile': {
  'description': {'type': 'string'}
  'email':       {'type': 'string', 'required': True}
  'firtsname':   {'type': 'string', 'required': True}
  'lastname':    {'type': 'string', 'required': True}
  'height':      {'type': 'float'}
}
\end{Verbatim}

\section{Mongoengine}

\begin{Verbatim}
class profile(Document):
    description = StringField()
    email = EmailField(required=True)
    firstname = StringField(required=True)
    lastname = StringField(required=True)
    height = FloatField(max_length=50)
\end{Verbatim}

\section{Cloudmesh Notation}

\begin{Verbatim}
profile:
    description: string
    email: email, required
    firstname: string, required
    lastname: string, required
    height: flat, max=10
\end{Verbatim}

\begin{Verbatim}
proposed command

cms schema FILENAME --format=mongo -o OUTPUT
cms schema FILENAME --format=cerberus -o OUTPUT
cms schema FILENAME --format=yaml -o OUTPUT

  reads FILENAME in cloudmesh notation and returns format


cms schema FILENAME --input=evegenie -o OUTPUT
   reads eavegene example and create settings for eve
\end{Verbatim}


\subsection{Defining Elements for the REST Service}

To manage a large number of elements defined in our REST service
easily, we manage them trhough definitions in yaml files. To generate
the appropriate settings file for the rest service, we can use teh
following command:

\begin{verbatim}
cms admin elements <directory> <out.json>
\end{verbatim}

where

\begin{itemize}
\item \verb+<directory>+: directory where the YAML definitions reside
\item \verb+<out.json>+: path to the combined definition
\end{itemize}

For example, to generate a file called all.json that integrates all
yml objects defined in the directory \verb+resources/samples+ you can
use the following command:

\begin{verbatim}
cms elements resources/samples all.json
\end{verbatim}

\subsection{DOIT}


cms schema spec2tex resources/specification resources/tex

\subsection{Generating service}

With evegenie installed, the generated JSON file from the above step
is processed to create the stub REST service definitions.


\section{Network}

We are looking for volunteers to contribute here.

\section{NEW}

\subsection{azure-size-simple}

\VerbatimInput{specification/azure-size-simple.yml}
\input{specification/azure-size.tex}

\subsection{azure-vm-simple}

\VerbatimInput{specification/azure-vm-simple.yml}
\input{specification/azure-vm.tex}

\subsection{batchjob-simple}

\VerbatimInput{specification/batchjob-simple.yml}
\input{specification/batchjob.tex}

\subsection{cluster-simple}

\VerbatimInput{specification/cluster-simple.yml}
\input{specification/cluster.tex}

\subsection{compute resource-simple}

\VerbatimInput{specification/compute_resource-simple.yml}
\input{specification/compute_resource.tex}

\subsection{computer-simple}

\VerbatimInput{specification/computer-simple.yml}
\input{specification/computer.tex}

\subsection{container-simple}

\VerbatimInput{specification/container-simple.yml}
\input{specification/container.tex}

\subsection{database-simple}

\VerbatimInput{specification/database-simple.yml}
\input{specification/database.tex}

\subsection{default-simple}

\VerbatimInput{specification/default-simple.yml}
\input{specification/default.tex}

\subsection{deployment-simple}

\VerbatimInput{specification/deployment-simple.yml}
\input{specification/deployment.tex}

\subsection{file-simple}

\VerbatimInput{specification/file-simple.yml}
\input{specification/file.tex}

\subsection{file alias-simple}

\VerbatimInput{specification/file_alias-simple.yml}
\input{specification/file_alias.tex}

\subsection{hadoop-simple}

\VerbatimInput{specification/hadoop-simple.yml}
\input{specification/hadoop.tex}

\subsection{key-simple}

\VerbatimInput{specification/key-simple.yml}
\input{specification/key.tex}

\subsection{kubernetes-simple}

\VerbatimInput{specification/kubernetes-simple.yml}
\input{specification/kubernetes.tex}

\subsection{mapreduce-simple}

\VerbatimInput{specification/mapreduce-simple.yml}
\input{specification/mapreduce.tex}

\subsection{mesos-simple}

\VerbatimInput{specification/mesos-simple.yml}
\input{specification/mesos.tex}

\subsection{microservice-simple}

\VerbatimInput{specification/microservice-simple.yml}
\input{specification/microservice.tex}

\subsection{node-simple}

A node is composed of multiple components:Metadata such as the
{\em name}  or {\em owner} .  Physical properties such as {\em cores}  or
{\em memory} .  Configuration guidance such as {\em create\_external\_ip} ,
{\em security\_groups} , or {\em users} . The metadata is associated with the
node on the provider end (if supported) as well as in the database.
Certain parts of the metadata (such as {\em owner} ) can be used to
implement access control.  Physical properties are relevant for the
initial allocation of the node.  Other configuration parameters
control and further provisioning.  In the above, after allocation, the
node is configured with a user called {\em hello}  who is part of the
{\em wheel}  group whose account can be accessed with several SSH
identities whose public keys are provided (in
{\em authorized\_keys} ). Additionally, three ssh keys are generated on
the node for the {\em hello}  user.  The first uses the {\em
      ed25519}    
cryptographic method with a password read in from a GPG-encrypted file
on the Command and Control node.  The second is a 4098-bit RSA key
also password-protected from the GPG-encrypted file.  The third key is
copied to the remote node from an encrypted file on the Command and
Control node.  This definition also provides a security group to
control access to the node from the wide-area-network.  In this case
all ingress and egress TCP and UDP traffic is allowed provided they
are to ports 22 (SSH), 443 (SSL), and 80 and 8080 (web). "


\VerbatimInput{specification/node-simple.yml}

\subsection{openstack flavor-simple}

\VerbatimInput{specification/openstack_flavor-simple.yml}
\input{specification/openstack_flavor.tex}

\subsection{openstack image-simple}

\VerbatimInput{specification/openstack_image-simple.yml}
\input{specification/openstack_image.tex}

\subsection{openstack vm-simple}

\VerbatimInput{specification/openstack_vm-simple.yml}
\input{specification/openstack_vm.tex}

\subsection{profile-simple}

\VerbatimInput{specification/profile-simple.yml}
\input{specification/profile.tex}

\subsection{replica-simple}

\VerbatimInput{specification/replica-simple.yml}
\input{specification/replica.tex}

\subsection{reservation-simple}

\VerbatimInput{specification/reservation-simple.yml}
\input{specification/reservation.tex}

\subsection{user-simple}

\VerbatimInput{specification/user-simple.yml}
\input{specification/user.tex}

\subsection{var-simple}

\VerbatimInput{specification/var-simple.yml}
\input{specification/var.tex}

\subsection{virtual cluster-simple}

\VerbatimInput{specification/virtual_cluster-simple.yml}
\input{specification/virtual_cluster.tex}

\subsection{virtual compute node-simple}

\VerbatimInput{specification/virtual_compute_node-simple.yml}
\input{specification/virtual_compute_node.tex}

\subsection{virtual directory-simple}

\VerbatimInput{specification/virtual_directory-simple.yml}
\input{specification/virtual_directory.tex}

\subsection{virtual machine-simple}

\VerbatimInput{specification/virtual_machine-simple.yml}
\input{specification/virtual_machine.tex}

\section{Schema Command}

\VerbatimInput{schema-man.tex}
\newpage

\appendix

{|bf README.rst}
\input{readme}
classes lessons rest.rst
\input{rest}
classes lesson python cmd5.rst
\input{python-cmd5}

\end{document}



